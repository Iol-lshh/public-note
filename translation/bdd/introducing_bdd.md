---
title: Introducing BDD 번역
date: 2025-07-18
description: BDD에 대한 소개(2006)
author: North Dan
---
- 원본: [Introducing BDD(North Dan, 2006)](https://dannorth.net/introducing-bdd/)

저는 문제가 있었습니다. 다양한 환경의 프로젝트에서 테스트 주도 개발(TDD)과 같은 애자일(agile) 방식을 사용하고 가르치면서 저는 같은 혼란과 오해를 계속 마주쳤습니다. 프로그래머들은 어디서부터 시작해야 할지, 무엇을 테스트하고 무엇을 테스트하지 말아야 할지, 한 번에 얼마나 테스트해야 할지, 테스트 이름을 무엇으로 지어야 할지, 그리고 테스트가 왜 실패하는지 어떻게 이해해야 할지 알고 싶어 했습니다. 

TDD에 깊이 파고들수록 저의 여정은 점진적인 숙련의 과정이라기보다는 일련의 막다른 골목이었다는 느낌을 받았습니다. 저는 "누군가 나에게 그걸 말해줬다면!"이라고 생각하는 경우가 "와, 문이 열렸네!"라고 생각하는 경우보다 훨씬 더 많았다는 것을 기억합니다. 저는 TDD를 모든 함정을 피하고 핵심 내용으로 곧바로 들어갈 수 있는 방식으로 제시하는 것이 가능하다고 결심했습니다.

저의 답변은 **행동 주도 개발**(BDD, behaviour-driven development)입니다. 이것은 기존의 애자일 관행에서 진화했으며, 애자일 소프트웨어 딜리버리에 익숙하지 않은 팀에게 더 접근하기 쉽고 효과적으로 만들도록 설계되었습니다. 시간이 지나면서 BDD는 애자일 분석과 자동화된 인수 테스트의 더 넓은 범위까지 포함하게 되었습니다.

## 테스트 메서드 이름은 문장이어야 합니다

저의 첫 번째 "아하!" 순간은 동료인 크리스 스티븐슨(Chris Stevenson)이 작성한 agiledox라는 겉보기에는 단순한 유틸리티를 보여줄 때 발생했습니다. 이 유틸리티는 JUnit 테스트 클래스를 가져와 메서드 이름을 일반 문장으로 출력합니다. 예를 들어, 다음과 같은 테스트 케이스는:

```java
public class CustomerLookupTest extends TestCase {
  testFindsCustomerById() {
    ...
  }

  testFailsForDuplicateCustomers() {
    ...
  }
  ...
}
```

다음과 같이 렌더링됩니다: 

```text
CustomerLookup
- finds customer by id
- fails for duplicate customers
- ...
```

"test"라는 단어는 클래스 이름과 메서드 이름에서 모두 제거되고, 카멜 케이스(camel-case) 메서드 이름은 일반 텍스트로 변환됩니다. 그것이 전부이지만, 그 효과는 놀랍습니다. 

개발자들은 이것이 문서화 작업의 일부를 대신해줄 수 있다는 것을 발견했고, 그래서 실제 문장 형태의 테스트 메서드를 작성하기 시작했습니다. 게다가, 비즈니스 도메인의 언어로 메서드 이름을 작성했을 때, 생성된 문서가 비즈니스 사용자, 분석가, 그리고 테스터들에게도 의미가 통한다는 것을 발견했습니다.

## 간단한 문장 템플릿으로 테스트 메서드를 집중시킵니다

그 다음 저는 테스트 메서드 이름을 "should"라는 단어로 시작하는 관례를 접하게 되었습니다. "The class **should** **do something**"이라는 이 문장 템플릿은 현재 클래스에 대한 테스트만 정의할 수 있도록 합니다. 이것은 당신을 집중하게 합니다. 만약 당신이 이 템플릿에 맞지 않는 이름을 가진 테스트를 작성하고 있다면, 그것은 해당 행동이 다른 곳에 속할 수 있음을 시사합니다. 

예를 들어, 저는 화면에서 입력을 검증하는 클래스를 작성하고 있었습니다. 대부분의 필드는 이름, 성 등 일반적인 고객 세부 정보였지만, 생년월일 필드와 나이 필드도 있었습니다. 저는 `ClientDetailsValidatorTest`에 `testShouldFailForMissingSurname`과 `testShouldFailForMissingTitle`과 같은 메서드를 작성하기 시작했습니다.

그러다 나이 계산에 들어가면서 복잡한 비즈니스 규칙의 세계로 들어섰습니다: 나이와 생년월일이 모두 제공되었지만 일치하지 않으면 어떻게 되는가? 생일이 오늘이면 어떻게 되는가? 생년월일만 있다면 나이를 어떻게 계산하는가? 이 행동을 설명하기 위해 점점 더 번거로운 테스트 메서드 이름을 작성하고 있었으므로, 다른 곳으로 넘기는 것을 고려했습니다. 이로 인해 저는 `AgeCalculator`라는 새 클래스를 도입하게 되었고, 그 자체의 `AgeCalculatorTest`를 갖게 되었습니다. 모든 나이 계산 행동은 계산기로 옮겨졌고, 그래서 유효성 검사기는 계산기와 제대로 상호 작용하는지 확인하기 위한 나이 계산 관련 테스트 하나만 필요했습니다.

하나의 클래스가 두 가지 이상의 일을 하고 있다면, 저는 보통 그것을 일부 작업을 수행할 다른 클래스를 도입해야 한다는 징후로 받아들입니다. 저는 새로운 서비스를 _그것이 무엇을 하는지_ 설명하는 인터페이스로 정의하고, 이 서비스를 클래스의 생성자를 통해 전달합니다:

```java
public class ClientDetailsValidator {

  private final AgeCalculator ageCalc;

  public ClientDetailsValidator(AgeCalculator ageCalc) {
    this.ageCalc = ageCalc;
  }
}
```

이러한 객체를 연결하는 방식은 [**의존성 주입**](https://www.martinfowler.com/articles/injection.html)(dependency injection)이라고 알려져 있으며, 모의 객체(mocks)와 함께 사용할 때 특히 유용합니다.

## 표현적인 테스트 이름은 테스트 실패 시 유용합니다

얼마 지나지 않아, 코드를 변경하다가 테스트가 실패하게 되면, 테스트 메서드 이름을 보고 코드의 의도된 행동을 식별할 수 있다는 것을 발견했습니다. 보통 다음 세 가지 중 하나가 발생했습니다:

• 버그를 도입했습니다. 제가 잘못했습니다. 해결책: 버그를 수정합니다.
• 의도된 행동은 여전히 유효하지만 다른 곳으로 옮겨졌습니다. 해결책: 테스트를 옮기고 어쩌면 변경합니다.
• 행동이 더 이상 올바르지 않습니다. 시스템의 전제가 변경되었습니다. 해결책: **테스트를 삭제합니다**.

후자는 애자일 프로젝트에서 당신의 이해가 진화함에 따라 발생할 가능성이 높습니다. 불행히도, 초보 TDD 사용자들은 마치 코드의 품질을 저하시키는 것처럼 테스트를 삭제하는 것에 대한 타고난 두려움을 가지고 있습니다.

"should"라는 단어의 더 미묘한 측면은 "will" 또는 "shall"과 같은 더 공식적인 대안과 비교할 때 분명해집니다. "Should"는 암묵적으로 테스트의 전제에 도전할 수 있도록 해줍니다: "정말 그래야 하는가? 정말?" 이것은 당신이 도입한 버그 때문에 테스트가 실패하는 것인지, 아니면 시스템 행동에 대한 당신의 이전 가정이 이제는 틀렸기 때문인지를 결정하기 쉽게 만듭니다.

## "test"보다 "Behaviour"이 더 유용한 단어입니다

이제 저는 "test"라는 단어를 제거하는 도구인 agiledox와 각 테스트 메서드 이름에 대한 템플릿을 갖게 되었습니다. 갑자기 사람들의 TDD에 대한 오해가 거의 항상 "test"라는 단어로 귀결된다는 생각이 들었습니다.

그렇다고 해서 테스팅이 TDD에 본질적이지 않다는 말은 아닙니다. 결과로 나오는 메서드 집합은 코드 작동을 보장하는 효과적인 방법입니다. 그러나 메서드가 시스템의 행동을 포괄적으로 설명하지 않는다면, 그것들은 당신에게 잘못된 안도감을 주고 있는 것입니다.

저는 TDD를 다루면서 "테스트" 대신 "행동"이라는 단어를 사용하기 시작했고, 그것이 잘 맞을 뿐만 아니라 전체 범주의 코칭 질문들이 마법처럼 사라지는 것을 발견했습니다. 이제 저는 TDD 질문들 중 일부에 대한 답을 갖게 되었습니다. 테스트 이름을 무엇으로 지을지는 쉽습니다: 그것은 당신이 관심 있는 다음 행동을 설명하는 문장입니다. 얼마나 테스트해야 하는지는 중요하지 않게 됩니다: 단일 문장으로 그렇게 많은 행동을 설명할 수 없습니다. 테스트가 실패할 때, 위에서 설명한 과정을 거치면 됩니다: 버그를 도입했거나, 행동이 옮겨졌거나, 또는 테스트가 더 이상 유효하지 않은 경우입니다.

테스트에 대한 생각에서 행동에 대한 생각으로의 전환이 너무나 심오하다고 생각하여, TDD를 BDD, 즉 행동 주도 개발이라고 부르기 시작했습니다.

## JBehave는 테스팅보다 행동을 강조합니다

2003년 말, 저는 말뿐이 아닌 행동으로 옮길 때라고 결정했습니다. 저는 JUnit을 대체할 JBehave라는 것을 작성하기 시작했습니다. 이것은 테스팅에 대한 모든 언급을 제거하고 행동 검증을 중심으로 구축된 어휘로 대체했습니다. 저는 새로운 행동 주도 만트라를 엄격하게 준수할 경우 그러한 프레임워크가 어떻게 진화할지 알아보기 위해 이것을 했습니다. 또한, 테스트 기반 어휘의 방해 없이 TDD와 BDD를 소개하는 데 귀중한 교육 도구가 될 것이라고 생각했습니다.

가상의 `CustomerLookup` 클래스에 대한 행동을 정의하기 위해, 예를 들어 `CustomerLookupBehaviour`라는 행동 클래스를 작성할 것입니다. 이 클래스에는 "should"라는 단어로 시작하는 메서드가 포함될 것입니다. 행동 러너는 행동 클래스를 인스턴스화하고, JUnit이 테스트에 대해 하는 것처럼 각 행동 메서드를 차례로 호출할 것입니다. 그것은 진행 상황을 보고하고 마지막에 요약을 출력할 것입니다.

저의 첫 번째 이정표는 JBehave를 자체 검증 가능하게 만드는 것이었습니다. 저는 JBehave가 스스로를 실행할 수 있게 할 행동만을 추가했습니다. 저는 모든 JUnit 테스트를 JBehave 행동으로 마이그레이션하고 JUnit과 동일한 즉각적인 피드백을 받을 수 있었습니다.

## 다음으로 가장 중요한 행동을 결정하십시오

그 다음 저는 비즈니스 가치라는 개념을 발견했습니다. 물론, 저는 항상 제가 소프트웨어를 어떤 이유로 작성한다는 것을 알고 있었지만, 제가 지금 작성하고 있는 코드의 가치에 대해서는 진정으로 생각해 본 적이 없었습니다. 다른 동료인 비즈니스 분석가 크리스 매츠(Chris Matts)는 행동 주도 개발의 맥락에서 비즈니스 가치에 대해 생각하게 만들었습니다. 

JBehave를 자체 호스팅 목표로 삼았을 때, 집중을 유지하는 데 정말 유용한 방법은 다음 질문을 던지는 것이었습니다: **시스템이 아직 하지 않는, 다음으로 가장 중요한 것은 무엇인가?** (What’s the next most important thing the system _doesn’t_ do?)

이 질문은 당신이 아직 구현하지 않은 기능의 가치를 식별하고 우선순위를 정하도록 요구합니다. 또한 행동 메서드 이름을 공식화하는 데 도움이 됩니다: 시스템은 X를 하지 않으며(여기서 X는 의미 있는 행동), X는 중요합니다. 즉, X를 해야 합니다. 따라서 다음 행동 메서드는 단순히 다음과 같습니다: 

```java
public void shouldDoX() {
  // ...
}
```

이제 저는 또 다른 TDD 질문, 즉 어디서부터 시작해야 하는지에 대한 답을 얻었습니다.

## 요구사항도 행동입니다

이 시점에서 저는 TDD가 어떻게 작동하는지 이해하고, 더 중요하게는 설명하는 데 도움이 되는 프레임워크와 제가 마주쳤던 모든 함정을 피하는 접근 방식을 갖게 되었습니다.

2004년 말, 제가 매츠에게 새로 발견한 행동 기반 어휘를 설명하고 있을 때, 그는 "그것은 분석과 똑같잖아"라고 말했습니다. 우리가 이것을 처리하는 동안 긴 침묵이 흘렀고, 우리는 이 모든 행동 주도적 사고를 요구사항 정의에 적용하기로 결정했습니다. 만약 우리가 분석가, 테스터, 개발자, 그리고 비즈니스를 위한 일관된 어휘를 개발할 수 있다면, 기술적인 사람들이 비즈니스 사람들과 대화할 때 발생하는 모호함과 의사소통 오류를 제거하는 데 상당한 진전을 이룰 수 있을 것입니다.

## BDD는 분석을 위한 "유비쿼터스 언어"를 제공합니다

이 무렵 에릭 에반스(Eric Evans)는 베스트셀러인 "도메인 주도 설계(Domain-Driven Design)"를 출판했습니다. 이 책에서 그는 비즈니스 도메인에 기반한 유비쿼터스 언어를 사용하여 시스템을 모델링하는 개념을 설명합니다. 이는 비즈니스 어휘가 코드베이스 전체에 스며들게 하는 것입니다. 

크리스와 저는 우리가 **분석 프로세스 자체**를 위한 유비쿼터스 언어를 정의하려고 한다는 것을 깨달았습니다! 우리는 좋은 시작점을 가지고 있었습니다. 회사 내에서 이미 다음과 같은 스토리 템플릿이 일반적으로 사용되고 있었습니다:

```gherkin
As a [X]
I want [Y]
so that [Z]
```

여기서 Y는 어떤 기능이고, Z는 기능의 이점 또는 가치이며, X는 이점을 얻을 사람(또는 역할)입니다. 이 템플릿의 강점은 스토리를 처음 정의할 때 스토리 제공의 가치를 식별하도록 강제한다는 점입니다. 스토리에 실제 비즈니스 가치가 없을 때는 종종 ". . . [어떤 기능]을 원합니다. [그냥 그래야 하니까요.]"와 같이 됩니다.이것은 일부 더 난해한 요구사항의 범위를 줄이는 것을 더 쉽게 만들 수 있습니다.

이 시작점부터 매츠와 저는 모든 애자일 테스터들이 이미 알고 있는 것을 발견하기 시작했습니다: 스토리의 행동은 단순히 그것의 **인수 기준**입니다. 시스템이 모든 인수 기준을 충족하면 올바르게 작동하는 것이고, 그렇지 않으면 그렇지 않습니다. 그래서 우리는 스토리의 인수 기준을 포착하기 위한 템플릿을 만들었습니다.

템플릿은 분석가들에게 인위적이거나 제약적인 느낌을 주지 않을 만큼 느슨해야 했지만, 스토리를 구성 요소로 분해하고 자동화할 수 있을 만큼 구조화되어야 했습니다. 우리는 인수 기준을 **시나리오** 형태로 설명하기 시작했으며, 이는 다음과 같은 형태를 취했습니다: 

```gherkin
Given some initial context (the givens),
When an event occurs,
Then ensure some outcomes.
```

설명을 위해 ATM 기계의 고전적인 예를 사용해 봅시다. 스토리 카드 중 하나는 다음과 같을 수 있습니다:

```text
Title: Customer withdraws cash**

As a customer,
I want to withdraw cash from an ATM,
so that I don't have to wait in line at the bank.
```

그렇다면 이 스토리를 언제 완료했는지 어떻게 알 수 있을까요? 고려해야 할 몇 가지 시나리오가 있습니다: 계좌에 잔액이 있을 수 있고, 계좌가 초과 인출되었지만 초과 인출 한도 내일 수 있으며, 계좌가 초과 인출 한도를 넘어섰을 수 있습니다. 물론, 계좌에 잔액이 있지만 이번 인출로 인해 초과 인출되는 경우나, 현금 인출기에 현금이 부족한 경우와 같은 다른 시나리오도 있을 것입니다.

주어진-이벤트-결과(given-when-then) 템플릿을 사용하면, 처음 두 시나리오는 다음과 같을 수 있습니다:

```gherkin
Scenario: Account is in credit

Given the account is in credit
And the card is valid
And the dispenser contains cash
When the customer requests cash
Then ensure the account is debited
And ensure cash is dispensed
And ensure the card is returned
```

"and"를 사용하여 여러 개의 'given'이나 여러 개의 'outcome'을 자연스럽게 연결하는 것에 주목하십시오. 

```gherkin
Scenario: Account is overdrawn past the overdraft limit

Given the account is overdrawn
And the card is valid
When the customer requests cash
Then ensure a rejection message is displayed
And ensure cash is not dispensed
And ensure the card is returned
```

두 시나리오 모두 동일한 이벤트를 기반으로 하며, 일부 'given'과 'outcome'을 공유하기도 합니다. 우리는 'given', 'event', 'outcome'을 재사용하여 이를 활용하고자 합니다.

## 인수 기준(Acceptance criteria)은 실행 가능(executable)해야 합니다

시나리오의 조각들—'given', 'event', 'outcome'—은 코드에 직접 표현될 수 있을 만큼 세분화되어 있습니다. JBehave는 시나리오 조각들을 Java 클래스에 직접 매핑할 수 있는 객체 모델을 정의합니다.

각 'given'을 나타내는 클래스를 작성합니다:

```java
public class AccountIsInCredit implements Given {
  public void setup(World world) {
    ...
  }
}

public class CardIsValid implements Given {
  public void setup(World world) {
    ...
  }
}
```

그리고 이벤트에 대한 클래스도 작성합니다: 

```java
public class CustomerRequestsCash implements Event {
  public void occurIn(World world) {
    ...
  }
}
```

그리고 결과에 대해서도 마찬가지입니다. 그런 다음 JBehave는 이 모든 것을 연결하고 실행합니다. 그것은 "세계(world)"를 생성하는데, 이는 단순히 객체를 저장할 공간이며, 순서대로 각 'given'에 전달하여 알려진 상태로 세계를 채울 수 있도록 합니다. 그런 다음 JBehave는 이벤트에게 세계에서 "발생하도록" 지시하며, 이는 시나리오의 실제 행동을 수행합니다. 마지막으로 JBehave는 우리가 스토리 대해 정의한 모든 'outcome'에 제어권을 전달합니다.

각 조각을 나타내는 클래스를 갖는 것은 다른 시나리오나 스토리에서 조각을 재사용할 수 있게 합니다. 처음에는 'given'과 'outcome'이 모의 객체(mocks)를 사용하여 계좌를 잔액 상태로 설정하거나 카드를 유효하게 설정하는 방식으로 구현됩니다. 이것들은 행동 구현의 시작점을 형성합니다. 애플리케이션을 구현함에 따라 'given'과 'outcome'은 당신이 구현한 실제 클래스를 사용하도록 변경되므로, 시나리오가 완료될 때쯤에는 적절한 **종단 간 기능 테스트**(end-to-end functional tests)가 됩니다.

## BDD의 현재와 미래

잠시 중단된 후, JBehave는 다시 활발히 개발되고 있습니다. 핵심 부분은 상당히 완성되어 있고 견고합니다. 다음 단계는 IntelliJ IDEA 및 Eclipse와 같은 인기 있는 Java IDE와의 통합입니다. 

데이브 아스텔스(Dave Astels)는 BDD를 적극적으로 홍보해 왔습니다. 그의 웹로그와 다양한 출판된 기사들은 활발한 활동을 촉발시켰는데, 특히 Ruby 언어로 BDD 프레임워크를 생산하는 rspec 프로젝트가 두드러집니다. 저는 Ruby로 JBehave를 구현할 rbehave 작업을 시작했습니다.

저의 동료 중 다수가 다양한 실제 프로젝트에서 BDD 기술을 사용해 왔으며, 이 기술들이 매우 성공적이라는 것을 발견했습니다. 인수 기준을 검증하는 JBehave 스토리 러너는 활발히 개발 중입니다.

비전은 비즈니스 분석가와 테스터가 일반 텍스트 편집기에서 스토리를 캡처하여 비즈니스 도메인의 언어로 된 행동 클래스 스텁을 생성할 수 있는 **라운드 트립 편집기(round-trip editor)**를 갖는 것입니다. BDD는 많은 사람들의 도움으로 발전했으며, 저는 그들 모두에게 크게 감사드립니다.

---

**판권(Colophon)**: 이 글은 2006년 3월 Better Software 잡지에 처음 게재되었습니다.
