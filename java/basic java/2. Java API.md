## 2.1. 타입
### 2.1.1. 원시 타입 (Primitive Types)
- **원시 타입(Primitive Types)**은 자바에서 객체가 아닌 가장 기본적인 데이터 유형입니다.
- 언어에 의해 미리 정의된 8개의 기본 타입이 있으며, 이는 자바 프로그램에서 데이터 조작의 기본 단위로 사용됩니다.
- **자바의 8가지 기본 타입**:
  - `byte`
  - `short`
  - `int`
  - `long`
  - `float`
  - `double`
  - `char`
  - `boolean`
- 객체와 달리, 기본 타입은 메모리에서 단순 값 자체를 저장하며, 객체 참조를 사용하지 않습니다.

#### 2.1.1.1. **byte**
- **크기**: 8비트 정수
- **범위**: -128 ~ 127
- **기본값**: 0
- **사용 사례**: 메모리 효율성이 중요한 큰 배열, 바이너리 데이터 처리, 파일 및 스트림 작업.

#### 2.1.1.2. **short**
- **크기**: 16비트 정수
- **범위**: -32,768 ~ 32,767
- **기본값**: 0
- **사용 사례**: 메모리를 절약해야 하지만 `byte` 범위가 부족한 경우.

#### 2.1.1.3. **int**
- **크기**: 32비트 정수
- **범위**: -2³¹ ~ 2³¹-1 (~-20억 ~ 20억)
- **기본값**: 0
- **사용 사례**: 일반적인 정수 데이터에 가장 많이 사용되는 타입.

#### 2.1.1.4. **long**
- **크기**: 64비트 정수
- **범위**: -2⁶³ ~ 2⁶³-1
- **기본값**: 0L
- **사용 사례**: 금융 계산, 타임스탬프, 고유 ID 등 `int`로 처리할 수 없는 큰 범위의 데이터.

#### 2.1.1.5. **float**
- **크기**: 32비트 부동소수점
- **범위**: ±3.40282347E+38F (소수점 약 6~7자리 정밀도)
- **기본값**: 0.0f
- **사용 사례**: 메모리 효율성이 중요한 부동소수점 배열, 정밀도가 덜 중요한 경우.

#### 2.1.1.6. **double**
- **크기**: 64비트 부동소수점
- **범위**: ±1.79769313486231570E+308 (소수점 약 15자리 정밀도)
- **기본값**: 0.0d
- **사용 사례**: 기본 소수점 타입으로, 과학 계산이나 화폐와 같이 정밀도가 중요한 경우.

#### 2.1.1.7. **char**
- **크기**: 16비트 유니코드 문자
- **범위**: 0 ~ 65,535 (유니코드 문자)
- **기본값**: `'\u0000'` (널 문자)
- **사용 사례**: 개별 문자나 유니코드 기호 저장.

#### 2.1.1.8. **boolean**
- **크기**: 1비트 (JVM에 따라 다름)
- **값**: `true` 또는 `false`
- **기본값**: `false`
- **사용 사례**: 논리 값 저장 및 조건문(`if`, `while` 등)에서 사용.

---
#### 기본 타입을 사용하는 이유
1. **효율성**:
   - 기본 타입은 값을 직접 저장하므로 메모리 할당 및 가비지 컬렉션의 오버헤드를 줄임.
2. **단순성**:
   - 간단한 문법과 연산을 제공.
3. **낮은 오버헤드**:
   - 숫자나 문자와 같은 간단한 값에 대해 객체보다 적은 메모리와 성능 비용.

#### 박싱(Boxing)과 언박싱(Unboxing)
- 자바에서는 각 기본 타입에 해당하는 **래퍼 클래스(Wrapper Class)**가 있습니다.  
 - 래퍼 클래스는 기본 타입을 객체처럼 다룰 수 있도록 합니다.
- **박싱(Boxing)**: 기본 타입을 해당 래퍼 클래스로 변환하는 과정.
- **언박싱(Unboxing)**: 래퍼 클래스를 다시 기본 타입으로 변환하는 과정.
- 객체의 유연성이 필요한 경우가 아니라면, 성능을 위해 기본 타입을 사용하는 것이 권장됩니다.
![](img/IMG_1267.webp)

### 2.1.2. 참조 타입
- Array, Object
- Deep / Shallow copy
- Immutable

## 2.2. 클래스와 객체
- 클래스
- 객체
- 생성자
- 필드
- 메서드
- 인터페이스와 추상클래스
## 2.3. 메서드 시그니처
- 메서드 구조
	- 메서드 시그니처
- 오버로딩
- 오버라이딩
## 2.4. 제어자 (Modifier)
- 접근 제어자 (Access Modifier)
- static
- final
- volatile
## 2.5. 객체지향 (OOP)

### 2.5.1. 특징
1. 추상화
2. 캡슐화
3. 상속
4. 다형성

![](img/IMG_1262.gif)

#### 2.5.1.1.  **추상화 (Abstraction)**
- **정의**: 객체의 **핵심 특징**만 보여주고, **구현 세부사항**은 숨기는 과정.
- **목적**: 불필요한 복잡성을 줄이고, 객체의 본질적인 기능에 집중.
- **예시**: `Vehicle` 클래스가 `stop`이라는 추상 메서드를 정의하고, 구체적인 구현은 하위 클래스에서 처리.
```java
  abstract class Vehicle {
      abstract void stop();
  }
  ```
  
#### 2.5.1.2. **캡슐화 (Encapsulation)**
- **정의**: 데이터(필드)와 메서드를 **하나의 단위(클래스)**로 묶고, 접근 제한자를 사용하여 외부로부터 보호.
- **목적**: 데이터 보호 및 제어된 접근 제공. 외부에서는 getter/setter를 통해서만 데이터 접근 가능.
- **예시**: `private` 필드를 사용하고, 이를 접근하는 `public` 메서드를 정의.
```java
class Vehicle {
    private String type;
    public String getType() {
        return type;
    }
    public void setType(String type) { 
        this.type = type;
    }
}
```
  
#### 2.5.1.3. **상속 (Inheritance)**
- **정의**: 기존 클래스(부모 클래스)의 속성과 메서드를 새로운 클래스(자식 클래스)가 물려받는 과정.
- **목적**: 코드 재사용성 증가 및 중복 코드 감소. 계층 구조를 통한 설계 개선.
- **예시**: `Car` 클래스가 `Vehicle` 클래스를 상속받아, 공통 기능을 재사용.
```java
class Vehicle {
    void start() {
        System.out.println("Vehicle is starting");
    }
}

class Car extends Vehicle {
    void drive() {
        System.out.println("Car is driving");
    }
}
```
  
#### 2.5.1.4. **다형성 (Polymorphism)**
- **정의**: **같은 이름의 메서드**가 객체에 따라 **다르게 동작**하는 기능.
- **목적**: 객체를 유연하게 처리하며, 동일한 인터페이스나 부모 클래스를 사용하는 여러 객체를 교환 가능하게 만듦.
- **예시**: 부모 클래스의 메서드를 재정의(오버라이딩)하여, 객체에 따라 다른 동작을 수행.

```java
class Vehicle {
    void stop() {
        System.out.println("Vehicle is stopping");
    }
}

class Car extends Vehicle {
    @Override
    void stop() {
        System.out.println("Car is stopping quickly");
    }
}

public class Main {
    public static void main(String[] args) {
        Vehicle myCar = new Car();
        myCar.stop();
    }
}
```

### 2.5.2. SOLID
- **SOLID 원칙**은 깨끗한 객체지향 프로그래밍(OOP)을 구현하기 위한 기본 가이드라인으로, Robert C. Martin이 제안했습니다.  
- SOLID 원칙은 완벽한 해결책은 아니지만, **효율적이고 이해하기 쉬우며 확장 가능한 코드**를 설계하는 데 필수적인 기준입니다. 
1. Single Responsibility
2. Open-Closed
3. Liscov Substitution
4. Interface Segregation
5. Dependency Inversion

![](img/IMG_1258.jpeg)

#### 2.5.2.1. 단일 책임 원칙 (Single Responsibility Principle, SRP)
- **"클래스는 변경의 이유가 하나뿐이어야 한다."**
- **핵심 아이디어**: 클래스는 단 하나의 책임만 가져야 하며, 그 책임과 관련된 변경 사항만 영향을 받아야 합니다.
- **장점**: 모듈화를 통해 코드 유지보수가 쉬워지고, 변경이 다른 곳에 미치는 영향을 최소화할 수 있습니다.
- 예시: 데이터베이스 작업과 사용자 인터페이스 로직을 한 클래스에 함께 두지 말고, 각 작업을 별도의 클래스로 나눕니다.
#### 2.5.2.2. 개방-폐쇄 원칙 (Open/Closed Principle, OCP)
- **"소프트웨어 엔티티는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다."**
- **핵심 아이디어**: 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있도록 설계합니다.
- **장점**: 코드 변경으로 인한 위험을 줄이고, 기능 확장을 유연하게 처리할 수 있습니다.
- 예시: 새로운 동작을 추가하기 위해 기존 코드를 수정하지 않고, 인터페이스를 구현하거나 기존 클래스를 상속받아 새로운 기능을 추가합니다.
#### 2.5.2.3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
- **"상위 클래스의 객체는 하위 클래스의 객체로 대체할 수 있어야 한다."**
- **핵심 아이디어**: 하위 클래스가 상위 클래스의 기대 동작을 깨지 않고 대체 가능해야 합니다.
- **장점**: 하위 클래스가 상위 클래스와 일관성을 유지하면, 코드의 유연성과 확장성이 향상됩니다.
- 예시: 상위 클래스의 메서드 동작을 변경하지 않고, 하위 클래스에서 이를 확장하거나 추가 동작을 구현합니다.
#### 2.5.2.4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
- **"클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 한다."**
- **핵심 아이디어**: 한 인터페이스에 너무 많은 기능을 담지 말고, **작고 명확한 역할**을 가진 인터페이스로 분리합니다.
- **장점**: 클라이언트가 불필요한 의존성을 피하고, 각 클라이언트에 적합한 인터페이스를 제공할 수 있습니다.
- 예시: "파일 읽기/쓰기" 인터페이스를 하나로 만들지 말고, `Readable`(읽기 전용)과 `Writable`(쓰기 전용) 인터페이스로 분리합니다.
#### 2.5.2.5. 의존 역전 원칙 (Dependency Inversion Principle, DIP)
- **"고수준 모듈은 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 한다."**
- **핵심 아이디어**: 구체적인 구현이 아닌 추상화에 의존하여 유연성을 높입니다.
- **장점**: 코드가 특정 구현에 묶이는 것을 방지하고, 변경에 대한 적응성을 높입니다.
- 예시: 특정 데이터베이스 라이브러리 대신, 데이터 액세스를 위한 추상 인터페이스를 사용하고, 구현체를 의존성 주입(DI)으로 제공받습니다.
#### 결론: 왜 SOLID 원칙의 중요성
- SOLID 원칙은 **확장 가능하고 유지보수하기 쉬운 코드**를 작성하는 데 도움을 줍니다.
- 이 원칙들은 객체지향 설계를 단순화하고, 코드의 유연성과 재사용성을 향상시킵니다.
- SOLID 원칙을 준수하면, 변화하는 요구사항에 더 잘 대응할 수 있는 소프트웨어를 설계할 수 있습니다.

---
## 2.6. 불변성



