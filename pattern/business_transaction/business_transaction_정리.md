---
title: Business Transaction 정리
date: 2025-04-10
description: Synchronous/Asynchronous, Block/Nonblock과 동기화(Synchronization) 대한 CS부터 비즈니스 트랜잭션까지
category:
  - pattern
---
![](./img/header.png)

비즈니스 트랜잭션은 시스템 트랜잭션과 다르다. 마틴 파울러의 [POEAA](https://iol-lshh.github.io/%ED%9A%8C%EA%B3%A0/EAA/EAA_%EC%A0%95%EB%A6%AC/)는 이 둘을 다음으로 설명한다.

- 시스템 트랜잭션: 애플리케이션에서 데이터베이스로 수행
- 비즈니스 트랜잭션: 사용자에게서 애플리케이션으로 수행

시스템 트랜잭션은 트랜잭션하면 바로 떠오르는 그거다. 동기적으로 ACID로 처리되어야 하는 것. 비즈니스 트랜잭션은 조금 다르다. **최종적 일관성**을 갖고 비동기적으로 처리될 수도 있다. 중요한 것은 **사용자로부터 요청을 받아 애플리케이션이 비즈니스 로직을 수행**한다는 것이다.

비즈니스 트랜잭션을 설명하기 위해 다음 내용들을 정리할 것이다.

- 동기(Synchronous)와 비동기(Asynchronous)
- 블로킹(Blocking)과 논블로킹(Non-Blocking)
- 동기화(Synchronization)

---

## 동기(Synchronous) vs 비동기(Asynchronous)

애플리케이션 단에서 동기와 비동기를 각각 한문장으로 정리하면 다음과 같다.

- **동기**(Synchronous): 요청하면 처리하고 알려줌.
	- 요청 → 처리 → 결과가 확정되기 전까지 다음 단계 X
- **비동기**(Asynchronous): 요청하면 처리하겠다고 알려주고, 처리함.
	- 요청 → 바로 응답 → 실제 처리와 결과 확정은 나중에

뭔가 이렇게 봤을때 동기와 비동기에 대해 이렇게 정의해 볼 수 있을 것 같다.

- **동기**는 로직의 **흐름 자체가 차례로 이어지는 구조**
- **비동기**는 로직의 **흐름을 기다리지 않고 갈라지는 구조**

**동기는 ‘흐름의 질서’이고, 비동기는 ‘흐름의 독립’이다.** (데이터 일관성에서의 독립이 아니다!)

또한 동기와 비동기는 블로킹/논블로킹과 같이 이야기 되어야 한다.

---

## 블로킹(Blocking) vs 논블로킹(Non-Blocking)

먼저 동기/비동기와 블로킹/논블로킹을 간단히 비교하면 다음과 같다.

- **동기/비동기**는 호출에 대해 **응답하는 방식**이다. 
- **블로킹/논블로킹**은 루틴의 처리에서 **대기 상황에 대한 대응 방식**이다. 

**대기**란 **결과를 기다리는 동안 아무것도 못하고 멈추는 상태**를 의미한다.

- I/O 대기. 데이터 올 때까지 멈춤 (디스크 읽기, 네트워크 응답, 파일 쓰기 등)
- 다른 쓰레드가 끝날 때까지 대기 (`Thread.join()`)
- 락 획득, 다른 작업 단위가 잡고 있으면 대기
- 조건 만족될 때까지 대기 (`sleep(5)` 호출)

I/O건 CPU건, 쓰레드건 상관없다. 중요한건 그것을 대기 상태라고 정의했는가 이다. 그리고 이런 대기 방식에 대해 블로킹/논블로킹이 적용된다.

- **블로킹**(Blocking): 루틴이 끝나서 결과 나올 때까지 기다린다. 그동안 다른 일을 하지 않는다.
- **논블로킹**(Non-Blocking): 루틴이 대기를 만나는 시점에 바로 반환한다. 결과가 없으면 “아직 없어!” 하고 끝난다.

동기/비동기와 블로킹/논블로킹을 조합해보면 다음과 같다.

|         | 블로킹                                                  | 논블로킹                                                                              |
| ------- | ---------------------------------------------------- | --------------------------------------------------------------------------------- |
| **동기**  | 대기할 것 다 기다려가며, **순차적으로 실행**한다.                       | 대기는 결과 처리가 없으면 없다고 바로 반환, 결과에 대한 데이터가 필요하기 때문에, 결과를 받을때까지 **반복해서 요청**(polling)한다. |
| **비동기** | 작업은 독립적으로 처리한다. 결과가 필요한 시점(async - await)이 생기면 기다린다. | 요청 접수 응답을 받고, 작업은 독립적으로 처리한다. 결과는 **콜백, 이벤트 등으로 나중에 전달** 받는다.                     |

비동기가 조금 헷갈리는데, JavaScript async-await을 떠올려보면 된다.

- async의 전체 흐름은 비동기다. (비동기 + 논블로킹)
- 하지만 await 관점에서는 **일시적으로 동기처럼 멈추는 구간**이다. (비동기 + 블로킹)
- async - await은 "**대기를 만나면, 나는 이 친구 기다려서 독립적으로 실행할꺼야! 알아서 할일들 해**" 하는 선언이다.

---

비즈니스 트랜잭션은 최종적 일관성을 가져야하는데, 이것은 동기로도 비동기로도 구현될 수 있다. 다만, 일관성을 위해서는 **흐름의 동기화**(Synchronization)도 같이 생각해야한다.

동기/비동기와 블로킹/논블로킹이 **흐름의 구조** 패턴이라면, 동기화는 **일관성을 위한 흐름 제어**를 목적으로 한다. 먼저 동기화에 대해 알아보자.

## 동기화(Synchronization)

위키백과에서는 동기화에 대해 이렇게 설명한다.

> 동기화(Synchronization)란 **시스템이 조화를 이루어 작동하도록 이벤트를 조율하는 것**을 말합니다. 예를 들어, 오케스트라의 지휘자(conductor)는 오케스트라가 동기화(synchronized)되거나 **일정한 시간(in time)에 맞춰 연주하도록 조율**합니다. 모든 부분이 동시에 작동하는 시스템은 동기적(synchronous) 또는 "동기화된(in sync)" 상태라고 하며, 그렇지 않은 경우를 [비동기](https://en.wikipedia.org/wiki/Asynchronous_system "비동기 시스템")적(asynchronous)이라고 합니다. - [동기화](https://en.wikipedia.org/wiki/Synchronization)

컴퓨터 과학 관점에서 조금더 세부적으로 정의를 찾아보면 다음과 같다.

> 동기화는 합의에 도달하거나 특정 일련의 동작을 수행하기 위해 여러 프로세스(multiple process)가 특정 지점에서 결합(join up)하거나 핸드셰이크(handsake) 하도록 조정(coordinating)하는 작업입니다. - [동기화(컴퓨터 과학)](https://en.wikipedia.org/wiki/Synchronization_(computer_science))

동기화란 **동시성(Concurrency) 시스템**에서 여러 실행 단위(프로세스/스레드)가 **의도한 올바른 순서로 작업을 수행**하게 만드는 기술이다. 즉, **타이밍 조율**이 핵심이다.

동기화란, **동시성 시스템에서 타이밍을 조절하는 기술** 이라고 정의할 수 있다.

- “**이 루틴 끝날 때까지 기다릴까?**” → 동기/비동기
- “**여러 작업이 한 자원에 접근하는데, 누가 먼저?**” → 동기화

그렇다면 동기화는 어디에 필요할까?

### 동기화가 필요한 곳

동기화는 결국 **동작 시점**에 대한 이야기다. 실행 순서를 정렬한다거나, 자원 획득을 기다리게 한다거나 하는 것이 목적이다. 크게 분류해보면 같다.

- 포크 - 조인 (Forks - Joins)
- 생산자 - 소비자 (Producer - Consumer)
- 배타적 자원 (Exclusive use resources)

#### [포크 - 조인](https://en.wikipedia.org/wiki/Fork%E2%80%93join_model "포크-조인 모델") (Forks - Joins)

로직이 포크(Fork)와 조인(Join)의 형태를 갖춘다면 동기화가 필요하다. 

- **포크**(Fork): 하나의 작업을 다수의 하위 작업으로 분할하는 것
- **조인**(Join): 다수의 작업을 하나의 작업으로 합치는 것

작업이 **포크**된다는 것은 **다수의 하위 작업으로 분할한다는 것**이다. 모든 하위 작업이 끝날때까지 대기하여, 작업의 결과를 전부 조인하고, 이후 로직을 실행해야 할 것이다. 이때, 포크 이후의 **하위 작업들을 동시에 작업할 수도 있을 것**인데, 조인 이후의 처리를 위해서는 하위 작업들이 전부 처리될 때까지 **타이밍을 기다려야 할 것**이다.

#### [생산자 - 소비자:](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem "생산자-소비자 문제") (Producer - Consumer)

로직이 생산자와 소비자로 분리되어 처리된다면 동기화가 필요하다,.

- **생산자**(Producer): 데이터를 만드는 주체
- **소비자**(Consumer): 데이터를 소비하는 주체

생산자-소비자 관계에서 소비자 프로세스는 필요한 데이터가 생성될 때까지 생산자 프로세스에 종속된다. **두 주체가 동시에 작업할 수도 있을 것**인데, 생산자가 데이터 생성할 때까지, 소비자는 **타이밍을 기다려야 할 것**이다.

#### 배타적 자원 (Exclusive use resources)

흔히 동기화에 대해 이야기할 때, 동시성 이슈와 관련된 대표적인 동기화 이슈이다. 여러 실행 단위들이 특정 리소스에 의존하고 **해당 리소스에 접근할 경우**, 한 시점에 단 하나의 실행 단위 만이 해당 리소스에 접근해야 한다. 이때 **실행 단위들은 동시에 작업할 수도 있을 것** 인데, 자신의 차례가 올 때까지 **타이밍을 기다려야 할 것**이다.

세 가지 경우를 모두 분석해보았을 때, 각 작업들 자체를 직렬적인 작업으로 수행할 수도 있다. 하지만 운영체제와 시스템에 있어, 동시성을 사용하지 않는다는 것은 매우 비효율적이다. 운영체제는 가상화를 통해 한정적인 CPU를 무한하게 보이도록 설계되었다. 한번에 여러 작업을 동시에 수행하는 것 처럼 보이도록 설계되어, 작업의 효율성을 높였다. 이런 주어진 자원을 사용하지 않을 이유가 없다. **동시성을 사용하되, 동기화를 통해 시스템의 일관성을 달성하는 것이 소프트웨어 엔지니어링의 목표**일 것이다.

### 동기화의 구현 기법들

여러 실행 단위가 올바른 순서로 작업을 수행해야 한다. 위 세 가지 경우를 보면 공통점이 있다. 어떤 **임계 영역**(Critical Section)에 대해서 타이밍을 기다려야한다는 것이다. 이때 Lock 메커니즘을 사용하는데, Lock 메커니즘은 다음과 같이 구현될 수 있다.

- **스핀락**(Spinlock): 작업이 공유 리소스를 얻기 위해 **짧은 시간 동안 계속 루프를 돌며 플래그를 확인**하는 방식이다. CPU를 계속 사용하며 대기하므로 플래그가 빠르게 바뀌는 경우에만 효율적이다. 그렇지 않으면 그냥 CPU 낭비한다.
- **배리어**(Barrier): **여러 작업이 특정 지점에 도달해야 다음 단계로 넘어갈 수 있도록 막는** 구조다.
- **세마포어**(Semaphore): **접근 가능한 개수(count) 만큼만 리소스 접근을 허용**하고, 초과하면 대기시킨다. 바이너리 세마포어는 1개의 리소스만 허용하므로 뮤텍스와 거의 같다.

---

## 비즈니스 트랜잭션

동기/비동기, 블락/논블락에 대해서 알아봤고, 동기화에 대해서 알아봤다. 이제 이 모든 것들을 합쳐서 비즈니스 트랜잭션을 이해할 때가 왔다.

**비즈니스 트랜잭션**은 사용자 요청을 받아 여러 단계를 거쳐 처리되는 논리적 트랜잭션이라고 했다. 만약 시스템이 여러 데이터베이스를 사용하고 있다면 어떻게 해야할까? 혹은 분산된 마이크로서비스로 잘게 쪼개져 있다면 어떻게 처리해야할까?

단순 쿼리 처리만 필요한 경우에는 일반적으로 **비동기 + 논블로킹 방식이 높은 효율을 보일 것이다.** 하지만 비즈니스 로직을 수행해야 한다면? 비즈니스 로직의 일관성을 보장하기 위해서는, 흐름 상 ‘동기 + 블로킹’처럼 동작하는 구조가 필요하다. 실제 구현은 **비동기 + 논블로킹**으로 처리하더라도, **로직의 순서와 타이밍은 동기적인 제어가 되어야 한다.** (이 글은 Saga 패턴이나 보상 트랜잭션같은 분산 트랜잭션 패턴보다, 일관성 확보라는 관점에 집중한다.)

하지만 그것이 전체 비즈니스 트랜잭션을, 다수의 서비스에 걸쳐 시스템 트랜잭션을 수행하라는 말이 아니다. 타이밍 제어에 대한 전략적인 설계를 위해서는 **분산 락**이 필요하다.

#### 분산 락

분산 락이란, 분산 시스템에서 공유하는 자원을 이용해 Lock을 구현한 것을 의미한다. 하지만 이 분산 락을 어떻게 이용해서 비즈니스 트랜잭션을 동기화 할 수 있을까? [MSSQL에는 Update Lock](https://iol-lshh.github.io/db/Isolation과_Lock_정리/)이란 것이 있다. 이 아이디어는 꽤나 쓸만하다.

먼저 MSSQL에서 사용하는 Lock을 알아보자.

- **배타 락**(Exclusive Lock): 배타 락이 획득 되었다면 어떤 다른 락도 획득 불가하다.
- **공유 락**(Shared Lock): 배타 락일 때 빼고 획득 가능하다.
- **업데이트 락**(Update Lock): 업데이트 락과 배타 락이 획득되어 있다면, 획득 불가능하다.

이렇게 단계적인 락은 쿼리에 레벨을 둘 수 있게 한다. 그렇다면 각 락이 사용되는 시점은 다음과 같을 것이다.

- **배타 락**: 쓰기 시점에 사용한다. 
- **업데이트 락**: 비즈니스 로직을 수행하는 시점에 사용한다. (비즈니스 로직 내부의 쿼리는 비즈니스 로직에 해당한다고 본다.)
- **공유 락**: 일관성이 중요한 쿼리에 사용한다.
- 락이 없음: 최종적 일관성만 중요한 쿼리에 사용한다.

동기적 기법들과 분산 락 아이디어를 이용한다면, 비동기 + 논블로킹 방식을 이용한 비즈니스 트랜잭션에서 동기/비동기 * 블로킹/논블로킹 방식들을 모두 구현할 수 있다. (이것은 운영체제 내부에서 동기적 아이디어를 이용해서 동기/비동기와 블로킹/논블로킹을 구현한 것과 같은 맥락일 것이다.)

---

**비즈니스 트랜잭션**은 사용자 요청을 받아 여러 단계를 거쳐 처리되는 논리적 트랜잭션이다. 시스템 트랜잭션처럼 단일 DB 안에서 끝나지 않고, 여러 서브 시스템, 메시지 큐, 외부 API, 데이터 저장 등을 포함하는 **복잡하고 긴 처리 흐름**을 가질 수 있다. 

이런 비즈니스 트랜잭션의 흐름에서는 **동기/비동기**, **블로킹/논블로킹** 구조를 상황에 맞게 조합하고,  
각 단계 간의 적절한 **동기화**(synchronization) 설계로 **신뢰성과 성능을 동시에 확보**해야 한다.

특히, 사용자 관점에서 이 모든 흐름은 **순차적이며 동기적인** 인터페이스로 느껴져야 한다. 바로 이것이 **최종적 일관성(eventual consistency)을 달성하는 핵심 전략**이며, 비즈니스 트랜잭션의 본질이다.
